# ä¸€ã€æ•°ç»„ä¸é“¾è¡¨åŸºç¡€

| é¢˜å·                                                      | é¢˜ç›®         | çŸ¥è¯†ç‚¹       | éš¾åº¦ |
| --------------------------------------------------------- | ------------ | ------------ | ---- |
| [27](https://leetcode.cn/problems/remove-element)         | ç§»é™¤å…ƒç´      | æ•°ç»„ã€åŒæŒ‡é’ˆ | Easy |
| [283](https://leetcode.cn/problems/move-zeroes)           | ç§»åŠ¨é›¶       | æ•°ç»„ã€åŒæŒ‡é’ˆ | Easy |
| [206](https://leetcode.cn/problems/reverse-linked-list)   | åè½¬é“¾è¡¨     | é“¾è¡¨åŸºç¡€     | Easy |
| [141](https://leetcode.cn/problems/linked-list-cycle)     | ç¯å½¢é“¾è¡¨     | å¿«æ…¢æŒ‡é’ˆ     | Easy |
| [21](https://leetcode.cn/problems/merge-two-sorted-lists) | åˆå¹¶æœ‰åºé“¾è¡¨ | é“¾è¡¨åˆå¹¶     | Easy |

## 27 åŸåœ°ç§»é™¤æ•°ç»„ä¸­ç‰¹å®šå…ƒç´ 

==åŒæŒ‡é’ˆ==

ç»™ä½ ä¸€ä¸ªæ•°ç»„ `nums` å’Œä¸€ä¸ªå€¼ `val`ï¼Œä½ éœ€è¦ **[åŸåœ°](https://baike.baidu.com/item/åŸåœ°ç®—æ³•)** ç§»é™¤æ‰€æœ‰æ•°å€¼ç­‰äº `val` çš„å…ƒç´ ã€‚å…ƒç´ çš„é¡ºåºå¯èƒ½å‘ç”Ÿæ”¹å˜ã€‚ç„¶åè¿”å› `nums` ä¸­ä¸ `val` ä¸åŒçš„å…ƒç´ çš„æ•°é‡ã€‚

å‡è®¾ `nums` ä¸­ä¸ç­‰äº `val` çš„å…ƒç´ æ•°é‡ä¸º `k`ï¼Œè¦é€šè¿‡æ­¤é¢˜ï¼Œæ‚¨éœ€è¦æ‰§è¡Œä»¥ä¸‹æ“ä½œï¼š

- æ›´æ”¹ `nums` æ•°ç»„ï¼Œä½¿ `nums` çš„å‰ `k` ä¸ªå…ƒç´ åŒ…å«ä¸ç­‰äº `val` çš„å…ƒç´ ã€‚`nums` çš„å…¶ä½™å…ƒç´ å’Œ `nums` çš„å¤§å°å¹¶ä¸é‡è¦ã€‚
- è¿”å› `k`

```python
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        insert_pos = 0
        for i in range(0,len(nums)):
            if nums[i] != val:
                nums[insert_pos] = nums[i]
                insert_pos += 1
        return insert_pos
```

## 283 ç§»åŠ¨0åˆ°æœ«å°¾

ç»™å®šä¸€ä¸ªæ•°ç»„ `nums`ï¼Œç¼–å†™ä¸€ä¸ªå‡½æ•°å°†æ‰€æœ‰ `0` ç§»åŠ¨åˆ°æ•°ç»„çš„æœ«å°¾ï¼ŒåŒæ—¶ä¿æŒéé›¶å…ƒç´ çš„ç›¸å¯¹é¡ºåºã€‚

**è¯·æ³¨æ„** ï¼Œå¿…é¡»åœ¨ä¸å¤åˆ¶æ•°ç»„çš„æƒ…å†µä¸‹åŸåœ°å¯¹æ•°ç»„è¿›è¡Œæ“ä½œ

```python
def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        insert_pos = 0
        for i in range(len(nums)):
            if nums[i] != 0:
                nums[insert_pos] = nums[i]
                insert_pos += 1
        for i in range(insert_pos,len(nums)):
            nums[i] = 0#å¤„ç†0å…ƒç´ å¾ˆé‡è¦
```

## 206 åè½¬é“¾è¡¨

ç»™ä½ å•é“¾è¡¨çš„å¤´èŠ‚ç‚¹ `head` ï¼Œè¯·ä½ åè½¬é“¾è¡¨ï¼Œå¹¶è¿”å›åè½¬åçš„é“¾è¡¨

è§£æ³•1 é€’å½’

```python
def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if head is None or head.next is None:
            return head
        newhead = reverseList(head.next)
        head.next.next = head
        head.next = None
        return newhead
```

è§£æ³•2 è¿­ä»£

æ‹†æˆä¸¤ä¸ªé“¾è¡¨æ¥çœ‹ï¼Œå·¦è¾¹æ˜¯åè½¬ä¹‹åçš„é“¾è¡¨ï¼Œå³è¾¹æ˜¯åˆå§‹é“¾è¡¨

```python
def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        pre = None
        cur = head
        while cur:
            temp = cur.next
            cur.next = pre
            pre = cur
            cur = temp
        return pre
```

## 141 åˆ¤æ–­é“¾è¡¨æœ‰æ— ç¯

ç»™ä½ ä¸€ä¸ªé“¾è¡¨çš„å¤´èŠ‚ç‚¹ `head` ï¼Œåˆ¤æ–­é“¾è¡¨ä¸­æ˜¯å¦æœ‰ç¯ã€‚

å¦‚æœé“¾è¡¨ä¸­æœ‰æŸä¸ªèŠ‚ç‚¹ï¼Œå¯ä»¥é€šè¿‡è¿ç»­è·Ÿè¸ª `next` æŒ‡é’ˆå†æ¬¡åˆ°è¾¾ï¼Œåˆ™é“¾è¡¨ä¸­å­˜åœ¨ç¯ã€‚ ä¸ºäº†è¡¨ç¤ºç»™å®šé“¾è¡¨ä¸­çš„ç¯ï¼Œè¯„æµ‹ç³»ç»Ÿå†…éƒ¨ä½¿ç”¨æ•´æ•° `pos` æ¥è¡¨ç¤ºé“¾è¡¨å°¾è¿æ¥åˆ°é“¾è¡¨ä¸­çš„ä½ç½®ï¼ˆç´¢å¼•ä» 0 å¼€å§‹ï¼‰ã€‚**æ³¨æ„ï¼š`pos` ä¸ä½œä¸ºå‚æ•°è¿›è¡Œä¼ é€’** ã€‚ä»…ä»…æ˜¯ä¸ºäº†æ ‡è¯†é“¾è¡¨çš„å®é™…æƒ…å†µã€‚

*å¦‚æœé“¾è¡¨ä¸­å­˜åœ¨ç¯* ï¼Œåˆ™è¿”å› `true` ã€‚ å¦åˆ™ï¼Œè¿”å› `false`

>å¿«æ…¢æŒ‡é’ˆï¼Œå¦‚æœæœ‰ç¯è·¯é‚£ä¹ˆå¿«çš„å¿…ç„¶ä¼šè¿½ä¸Šæ…¢çš„ï¼Œå¦‚æœè¿½ä¸ä¸Šfaståˆ°è¾¾ç»ˆç‚¹ï¼Œé‚£ä¹ˆè¯´æ˜æ²¡æœ‰ç¯

```python
def hasCycle(self, head: Optional[ListNode]) -> bool:
        slow = head
        fast = head
        while fast is not None and fast.next is not None:
            slow = slow.next
            fast = fast.next.next
            if slow == fast:
                return True
        return False
```

## 21 å‡åºåˆå¹¶é“¾è¡¨

å°†ä¸¤ä¸ªå‡åºé“¾è¡¨åˆå¹¶ä¸ºä¸€ä¸ªæ–°çš„ **å‡åº** é“¾è¡¨å¹¶è¿”å›ã€‚æ–°é“¾è¡¨æ˜¯é€šè¿‡æ‹¼æ¥ç»™å®šçš„ä¸¤ä¸ªé“¾è¡¨çš„æ‰€æœ‰èŠ‚ç‚¹ç»„æˆçš„

>è¿™ä¸ªé€»è¾‘è·Ÿæˆ‘ä¹‹å‰é‡åˆ°çš„åˆå¹¶æ•°ç»„å…¶å®æ˜¯å®Œå…¨ä¸€æ ·çš„ï¼Œä¸è¿‡åœ¨é“¾è¡¨ä¸­éœ€è¦æ–°å»ºä¸€ä¸ªèŠ‚ç‚¹æ¥å­˜å‚¨ç­”æ¡ˆï¼Œ

```python
def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        res = ListNode()
        tail = res
        while list1 and list2:
            if list1.val <= list2.val:
                tail.next = list1
                list1 = list1.next
            else:
                tail.next = list2
                list2 = list2.next
            tail = tail.next
        if list1:
            tail.next = list1
        if list2:
            tail.next = list2
        return res.next
```



------

# äºŒã€æ’åºç®—æ³•é…å¥—é¢˜ç›®

| é¢˜å·                                                         | é¢˜ç›®           | æ¨èå¯¹åº”                | éš¾åº¦   |
| ------------------------------------------------------------ | -------------- | ----------------------- | ------ |
| [912](https://leetcode.cn/problems/sort-an-array)            | æ’åºæ•°ç»„       | å¿«é€Ÿæ’åº / å½’å¹¶æ’åºå®ç° | Medium |
| [147](https://leetcode.cn/problems/insertion-sort-list)      | æ’å…¥æ’åºé“¾è¡¨ç‰ˆ | æ’å…¥æ’åºæ€æƒ³ + é“¾è¡¨     | Medium |
| [148](https://leetcode.cn/problems/sort-list)                | æ’åºé“¾è¡¨       | å¿«æ’ or å½’å¹¶            | Medium |
| [215](https://leetcode.cn/problems/kth-largest-element-in-an-array) | ç¬¬Kå¤§å…ƒç´       | å¿«æ’æ€æƒ³                | Medium |

## 912

ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ `nums`ï¼Œè¯·ä½ å°†è¯¥æ•°ç»„å‡åºæ’åˆ—ã€‚

ä½ å¿…é¡»åœ¨ **ä¸ä½¿ç”¨ä»»ä½•å†…ç½®å‡½æ•°** çš„æƒ…å†µä¸‹è§£å†³é—®é¢˜ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º `O(nlog(n))`ï¼Œå¹¶ä¸”ç©ºé—´å¤æ‚åº¦å°½å¯èƒ½å°ã€‚

è§£ç­”1 å¿«é€Ÿæ’åº

```python
class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
        if len(nums)<2:
            return nums
        pivot = nums[0]
        less = [i for i in nums[1:] if i <= pivot]
        more = [i for i in nums[1:] if i > pivot]
        return self.sortArray(less) + [pivot] + self.sortArray(more)
```

è§£ç­”2 å½’å¹¶æ’åº

```python
class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
        if len(nums)<2:
            return nums
        mid = len(nums) // 2
        left = self.sortArray(nums[:mid])
        right = self.sortArray(nums[mid:])
        return self.merge(left, right)
    def merge(self,left,right):
        i = 0
        j = 0
        res = []
        while i<len(left) and j<len(right):
            if left[i] <= right[j]:
                res.append(left[i])
                i += 1
            else:
                res.append(right[j])
                j += 1
        res.extend(left[i:])
        res.extend(right[j:])
        return res

```

## 147

æ€è·¯ä¸æ•°ç»„çš„æ’å…¥æ’åºç±»ä¼¼ï¼Œå·¦ä¾§ç»´æŠ¤ä¸€ä¸ªå·²ç»æ’å¥½åºçš„é“¾è¡¨ï¼Œå³ä¾§æ˜¯éœ€è¦æ’åºçš„é“¾è¡¨

```python
class Solution:
    def insertionSortList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(0)
        curr = head
        while curr:
            prev = dummy#æ¯ä¸€æ¬¡éƒ½ä»å¤´éå†å·¦ä¾§é“¾è¡¨
            while prev.next and prev.next.val < curr.val:#ç›´åˆ°æ‰¾åˆ°æ›´å¤§çš„ï¼Œæ’å…¥ä½ç½®æ‰¾åˆ°
                prev = prev.next
            temp = curr.next#æŠŠä¸‹ä¸€ä¸ªéœ€è¦å¤„ç†çš„å…ˆä¿å­˜
            curr.next = prev.next#è®©curræŒ‡å‘ä¹‹å‰æ‰¾åˆ°çš„æ¯”å®ƒå¤§çš„
            prev.next = curr#è®©prevæŒ‡å‘currï¼Œè¿™æ ·å°±æ’è¿›æ¥äº†
            curr = temp#æŠŠcurrå‘å³ä¾§ç§»åŠ¨
        return dummy.next#æœ€åè¿”å›æ•´ä¸ªé“¾è¡¨
```

## 148 é“¾è¡¨çš„å½’å¹¶æ’åº

æ€è·¯ï¼šç”¨å¿«æ…¢ä¸¤ä¸ªæŒ‡é’ˆæŠŠé“¾è¡¨æ‹†åˆ†æˆå·¦å³ä¸¤ä¾§ï¼Œä¸¤ä¾§åˆ†åˆ«ä½¿ç”¨ï¼Œæœ€åå†åˆå¹¶ï¼Œåˆå¹¶çš„é€»è¾‘æ³¨æ„éœ€è¦ç”¨ä¸€ä¸ªè™šheadæ¥ç»´æŠ¤

```python
class Solution:
    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if head is None or head.next is None:
            return head
        fast = head.next
        slow = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
        mid = slow
        slow.next = None
        l1 = self.sortList(head)
        l2 = self.sortList(mid)
        return self.merge(l1,l2)
    def merge(self,l1,l2):
        dummy = ListNode(0)
        tail = dummy
        while l1 and l2:
            if l1.val < l2.val:
                tail.next = l1
                l1 = l1.next
                tail = tail.next     
            else:
                tail.next = l2
                l2 = l2.next
                tail = tail.next
        tail.next = l1 or l2
        return dummy.next 
```

## 215

ç»™å®šæ•´æ•°æ•°ç»„ `nums` å’Œæ•´æ•° `k`ï¼Œè¯·è¿”å›æ•°ç»„ä¸­ç¬¬ **k**ä¸ªæœ€å¤§çš„å…ƒç´ ã€‚

è¯·æ³¨æ„ï¼Œä½ éœ€è¦æ‰¾çš„æ˜¯æ•°ç»„æ’åºåçš„ç¬¬ `k` ä¸ªæœ€å¤§çš„å…ƒç´ ï¼Œè€Œä¸æ˜¯ç¬¬ `k` ä¸ªä¸åŒçš„å…ƒç´ ã€‚

ä½ å¿…é¡»è®¾è®¡å¹¶å®ç°æ—¶é—´å¤æ‚åº¦ä¸º `O(n)` çš„ç®—æ³•è§£å†³æ­¤é—®é¢˜

```python
class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        nums = self.sort(nums)
        return nums[-k]
    def sort(self,nums):   
        if len(nums) < 2:
            return nums
        pivot = nums[0]
        l1 = [i for i in nums[1:] if i <= pivot]
        l2 = [i for i in nums[1:] if i > pivot]
        return self.sort(l1)+[pivot]+self.sort(l2)
```



------

# ä¸‰ã€é€’å½’è®­ç»ƒé¢˜

| é¢˜å·                                                         | é¢˜ç›®         | æ¶‰åŠæ€æƒ³      | éš¾åº¦ |
| ------------------------------------------------------------ | ------------ | ------------- | ---- |
| [509](https://leetcode.cn/problems/fibonacci-number)         | æ–æ³¢é‚£å¥‘æ•°   | é€’å½’å…¥é—¨      | Easy |
| [70](https://leetcode.cn/problems/climbing-stairs)           | çˆ¬æ¥¼æ¢¯       | é€’å½’ + è®°å¿†åŒ– | Easy |
| [104](https://leetcode.cn/problems/maximum-depth-of-binary-tree) | æ ‘çš„æœ€å¤§æ·±åº¦ | æ ‘ + é€’å½’     | Easy |

## 509 æ–æ³¢é‚£å¥‘æ•°

æ–¹æ³•1ï¼šåŠ¨æ€è§„åˆ’

```python
class Solution:
    def fib(self, n: int) -> int:
        fib_l = [0] * (n+1)
        if n == 0:
            return 0
        if n == 1:
            return 1
        fib_l = [0] * (n + 1)
        fib_l[0] = 0
        fib_l[1] = 1
        for i in range(2,len(fib_l)):
            fib_l[i] = fib_l[i-1] + fib_l[i-2]
        return fib_l[n]

```

æ–¹æ³•2:é€’å½’

```python
class Solution:
    def fib(self, n: int) -> int:
        if n == 0:
            return 0
        if n == 1:
            return 1
        else:
            return self.fib(n-1)+self.fib(n-2)        
```

ç¼ºç‚¹ï¼šæ•ˆç‡ä½ï¼Œæ—¶é—´å¤æ‚åº¦ $O(2^n)$

## 70 çˆ¬æ¥¼æ¢¯

é€’å½’å†™æ³•ï¼ˆæ•ˆç‡å¾ˆä½ï¼‰

```python
class Solution:
    def climbStairs(self, n: int) -> int:
        if n == 1:
            return 1
        if n == 2:
            return 2
        else:
            return self.climbStairs(n-1)+self.climbStairs(n-2)
```

åŠ¨æ€è§„åˆ’å†™æ³•

```python
class Solution:
    def climbStairs(self, n: int) -> int:
        if n == 1:
            return 1
        if n == 2:
            return 2
        c_l = [0] * (n+1)
        c_l[1] = 1
        c_l[2] = 2
        for i in range(3,len(c_l)):
            c_l[i] = c_l[i-1] + c_l[i-2]  
        return c_l[n]
```

## 104 æ ‘çš„æœ€å¤§æ·±åº¦

é€’å½’å†™æ³•

```python
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        if root is None:
            return 0
        left_depth = self.maxDepth(root.left)
        right_depth = self.maxDepth(root.right)
        return max(left_depth,right_depth) + 1
```



------

# å››ã€æ•£åˆ—è¡¨ä¸å“ˆå¸Œç»“æ„

| é¢˜å·                                                         | é¢˜ç›®             | çŸ¥è¯†ç‚¹   | éš¾åº¦ |
| ------------------------------------------------------------ | ---------------- | -------- | ---- |
| [1](https://leetcode.cn/problems/two-sum)                    | ä¸¤æ•°ä¹‹å’Œ         | å“ˆå¸ŒæŸ¥è¡¨ | Easy |
| [242](https://leetcode.cn/problems/valid-anagram)            | æœ‰æ•ˆçš„å­—æ¯å¼‚ä½è¯ | å“ˆå¸Œè®¡æ•° | Easy |
| [349](https://leetcode.cn/problems/intersection-of-two-arrays) | ä¸¤æ•°ç»„äº¤é›†       | set è¿ç®— | Easy |

## 1 å“ˆå¸Œæ±‚å’Œ

å¤æ‚åº¦ $O(n)$éå¸¸ä¼˜ç§€

ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ `nums` å’Œä¸€ä¸ªæ•´æ•°ç›®æ ‡å€¼ `target`ï¼Œè¯·ä½ åœ¨è¯¥æ•°ç»„ä¸­æ‰¾å‡º **å’Œä¸ºç›®æ ‡å€¼** *`target`* çš„é‚£ **ä¸¤ä¸ª** æ•´æ•°ï¼Œå¹¶è¿”å›å®ƒä»¬çš„æ•°ç»„ä¸‹æ ‡ä½ å¯ä»¥å‡è®¾æ¯ç§è¾“å…¥åªä¼šå¯¹åº”ä¸€ä¸ªç­”æ¡ˆï¼Œå¹¶ä¸”ä½ ä¸èƒ½ä½¿ç”¨ä¸¤æ¬¡ç›¸åŒçš„å…ƒç´ ä½ å¯ä»¥æŒ‰ä»»æ„é¡ºåºè¿”å›ç­”æ¡ˆ

```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        hashmap = {}
        for i in range(len(nums)):
            num = nums[i]
            pare = target - num
            if pare in hashmap:
                return [hashmap[pare],i]
            hashmap[num] = i
#key:æ•°å­—ï¼Œvalue:ç´¢å¼•å·
```

## 242 å­—æ¯å¼‚ä½è¯

>`dict.get(key, default)`
> è¡¨ç¤ºï¼šä»å­—å…¸ä¸­è·å–æŒ‡å®š `key` å¯¹åº”çš„å€¼ï¼Œå¦‚æœè¿™ä¸ª `key` ä¸å­˜åœ¨ï¼Œå°±è¿”å›é»˜è®¤å€¼ `default`ï¼ˆé»˜è®¤æ˜¯ `None`ï¼‰ã€‚

```python
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
      
        if len(s) != len(t):
            return False

        hashmap1 = {}
        hashmap2 = {}

        for ch in s:
            hashmap1[ch] = hashmap1.get(ch, 0) + 1

        for ch in t:
            hashmap2[ch] = hashmap2.get(ch, 0) + 1

        return hashmap1 == hashmap2

```

## 349 æ•°ç»„äº¤é›†

æ€è·¯ï¼šä¸€ä¸ªæ•°ç»„ç”¨æ¥å»ºç«‹æŸ¥è¯¢å­—å…¸ï¼Œä¸€ä¸ªæ•°ç»„æ¥åŒ¹é…

```python
class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        hashmap = {}
        res = set()
        for i in nums1:
            hashmap[i] = True
        for i in nums2:
            if i in hashmap:
                res.add(i)
        return list(res)
```



------

# äº”ã€æ ‘ï¼ˆé‡ç‚¹æ˜¯äºŒå‰æ ‘ã€å“ˆå¤«æ›¼æ ‘æ€æƒ³ï¼‰

| é¢˜å·                                                         | é¢˜ç›®              | æ¶‰åŠç»“æ„    | éš¾åº¦   |
| ------------------------------------------------------------ | ----------------- | ----------- | ------ |
| [144](https://leetcode.cn/problems/binary-tree-preorder-traversal) | äºŒå‰æ ‘å‰åºéå†    | é€’å½’/æ ˆæ¨¡æ‹Ÿ | Easy   |
| [145](https://leetcode.cn/problems/binary-tree-postorder-traversal) | ååºéå†          | æ ‘ + é€’å½’   | Easy   |
| [226](https://leetcode.cn/problems/invert-binary-tree)       | ç¿»è½¬äºŒå‰æ ‘        | é€’å½’        | Easy   |
| [105](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal) | æ ¹æ®å‰åº+ä¸­åºå»ºæ ‘ | æ„é€ æ ‘ç»“æ„  | Medium |

ğŸ“Œ å“ˆå¤«æ›¼æ ‘ç›¸å…³ï¼šå»ºè®®ç†è§£â€œæœ€ä¼˜åˆå¹¶â€æ€æƒ³ï¼Œå¯æŸ¥låŠ›æ‰£ä¸Šåˆå¹¶çŸ³å¤´çš„é¢˜ï¼ˆ[1005](https://leetcode.cn/problems/stones-on-the-table) ç±»ä¼¼ä½†ä¸å®Œå…¨å¯¹åº”ï¼‰

------

# å…­ã€Dijkstra æœ€çŸ­è·¯å¾„

| é¢˜å·                                                         | é¢˜ç›®         | çŸ¥è¯†ç‚¹        | éš¾åº¦   |
| ------------------------------------------------------------ | ------------ | ------------- | ------ |
| [743](https://leetcode.cn/problems/network-delay-time)       | ç½‘ç»œå»¶è¿Ÿæ—¶é—´ | Dijkstra ç®—æ³• | Medium |
| [1631](https://leetcode.cn/problems/path-with-minimum-effort) | æœ€å°ä½“åŠ›è·¯å¾„ | Dijkstra è¿›é˜¶ | Medium |

âš ï¸ æ³¨æ„ï¼šå›¾è®ºé¢˜è¾ƒéš¾ï¼Œå…ˆç†è§£ä½ è¯¾å ‚ä¸Šå®ç°çš„ Dijkstraï¼Œåˆ· [743] å°±å¾ˆè¶³å¤Ÿï¼

------

# ä¸ƒã€è´ªå¿ƒ & NP å®Œå…¨é—®é¢˜è¿‘ä¼¼è§£

| é¢˜å·                                                         | é¢˜ç›®       | æ¶‰åŠç­–ç•¥      | éš¾åº¦             |
| ------------------------------------------------------------ | ---------- | ------------- | ---------------- |
| [455](https://leetcode.cn/problems/assign-cookies)           | åˆ†å‘é¥¼å¹²   | è´ªå¿ƒ          | Easy             |
| [135](https://leetcode.cn/problems/candy)                    | åˆ†å‘ç³–æœ   | è´ªå¿ƒ+ä¸¤éæ‰«æ | Hardï¼ˆæ€è·¯ç®€å•ï¼‰ |
| [435](https://leetcode.cn/problems/non-overlapping-intervals) | æ— é‡å åŒºé—´ | åŒºé—´è°ƒåº¦      | Medium           |

ğŸ“Œ è¿™äº›é¢˜éƒ½å¯ä»¥ç”¨â€œå±€éƒ¨æœ€ä¼˜â€æ€æƒ³å†™å‡ºâ€œè¿‘ä¼¼æœ€ä¼˜è§£â€ï¼Œç¬¦åˆä½ è¯¾ä¸Š NP å®Œå…¨é—®é¢˜éƒ¨åˆ†çš„å®šä½ã€‚

