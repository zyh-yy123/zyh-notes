# 一、数组与链表基础

| 题号                                                      | 题目         | 知识点       | 难度 |
| --------------------------------------------------------- | ------------ | ------------ | ---- |
| [27](https://leetcode.cn/problems/remove-element)         | 移除元素     | 数组、双指针 | Easy |
| [283](https://leetcode.cn/problems/move-zeroes)           | 移动零       | 数组、双指针 | Easy |
| [206](https://leetcode.cn/problems/reverse-linked-list)   | 反转链表     | 链表基础     | Easy |
| [141](https://leetcode.cn/problems/linked-list-cycle)     | 环形链表     | 快慢指针     | Easy |
| [21](https://leetcode.cn/problems/merge-two-sorted-lists) | 合并有序链表 | 链表合并     | Easy |

## 27 原地移除数组中特定元素

==双指针==

给你一个数组 `nums` 和一个值 `val`，你需要 **[原地](https://baike.baidu.com/item/原地算法)** 移除所有数值等于 `val` 的元素。元素的顺序可能发生改变。然后返回 `nums` 中与 `val` 不同的元素的数量。

假设 `nums` 中不等于 `val` 的元素数量为 `k`，要通过此题，您需要执行以下操作：

- 更改 `nums` 数组，使 `nums` 的前 `k` 个元素包含不等于 `val` 的元素。`nums` 的其余元素和 `nums` 的大小并不重要。
- 返回 `k`

```python
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        insert_pos = 0
        for i in range(0,len(nums)):
            if nums[i] != val:
                nums[insert_pos] = nums[i]
                insert_pos += 1
        return insert_pos
```

## 283 移动0到末尾

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**请注意** ，必须在不复制数组的情况下原地对数组进行操作

```python
def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        insert_pos = 0
        for i in range(len(nums)):
            if nums[i] != 0:
                nums[insert_pos] = nums[i]
                insert_pos += 1
        for i in range(insert_pos,len(nums)):
            nums[i] = 0#处理0元素很重要
```

## 206 反转链表

给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表

解法1 递归

```python
def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if head is None or head.next is None:
            return head
        newhead = reverseList(head.next)
        head.next.next = head
        head.next = None
        return newhead
```

解法2 迭代

拆成两个链表来看，左边是反转之后的链表，右边是初始链表

```python
def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        pre = None
        cur = head
        while cur:
            temp = cur.next
            cur.next = pre
            pre = cur
            cur = temp
        return pre
```

## 141 判断链表有无环

给你一个链表的头节点 `head` ，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。**注意：`pos` 不作为参数进行传递** 。仅仅是为了标识链表的实际情况。

*如果链表中存在环* ，则返回 `true` 。 否则，返回 `false`

>快慢指针，如果有环路那么快的必然会追上慢的，如果追不上fast到达终点，那么说明没有环

```python
def hasCycle(self, head: Optional[ListNode]) -> bool:
        slow = head
        fast = head
        while fast is not None and fast.next is not None:
            slow = slow.next
            fast = fast.next.next
            if slow == fast:
                return True
        return False
```

## 21 升序合并链表

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的

>这个逻辑跟我之前遇到的合并数组其实是完全一样的，不过在链表中需要新建一个节点来存储答案，

```python
def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        res = ListNode()
        tail = res
        while list1 and list2:
            if list1.val <= list2.val:
                tail.next = list1
                list1 = list1.next
            else:
                tail.next = list2
                list2 = list2.next
            tail = tail.next
        if list1:
            tail.next = list1
        if list2:
            tail.next = list2
        return res.next
```



------

# 二、排序算法配套题目

| 题号                                                         | 题目           | 推荐对应                | 难度   |
| ------------------------------------------------------------ | -------------- | ----------------------- | ------ |
| [912](https://leetcode.cn/problems/sort-an-array)            | 排序数组       | 快速排序 / 归并排序实现 | Medium |
| [147](https://leetcode.cn/problems/insertion-sort-list)      | 插入排序链表版 | 插入排序思想 + 链表     | Medium |
| [148](https://leetcode.cn/problems/sort-list)                | 排序链表       | 快排 or 归并            | Medium |
| [215](https://leetcode.cn/problems/kth-largest-element-in-an-array) | 第K大元素      | 快排思想                | Medium |

## 912

给你一个整数数组 `nums`，请你将该数组升序排列。

你必须在 **不使用任何内置函数** 的情况下解决问题，时间复杂度为 `O(nlog(n))`，并且空间复杂度尽可能小。

解答1 快速排序

```python
class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
        if len(nums)<2:
            return nums
        pivot = nums[0]
        less = [i for i in nums[1:] if i <= pivot]
        more = [i for i in nums[1:] if i > pivot]
        return self.sortArray(less) + [pivot] + self.sortArray(more)
```

解答2 归并排序

```python
class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
        if len(nums)<2:
            return nums
        mid = len(nums) // 2
        left = self.sortArray(nums[:mid])
        right = self.sortArray(nums[mid:])
        return self.merge(left, right)
    def merge(self,left,right):
        i = 0
        j = 0
        res = []
        while i<len(left) and j<len(right):
            if left[i] <= right[j]:
                res.append(left[i])
                i += 1
            else:
                res.append(right[j])
                j += 1
        res.extend(left[i:])
        res.extend(right[j:])
        return res

```



------

# 三、递归训练题

| 题号                                                         | 题目         | 涉及思想      | 难度 |
| ------------------------------------------------------------ | ------------ | ------------- | ---- |
| [509](https://leetcode.cn/problems/fibonacci-number)         | 斐波那契数   | 递归入门      | Easy |
| [70](https://leetcode.cn/problems/climbing-stairs)           | 爬楼梯       | 递归 + 记忆化 | Easy |
| [104](https://leetcode.cn/problems/maximum-depth-of-binary-tree) | 树的最大深度 | 树 + 递归     | Easy |

------

# 四、散列表与哈希结构

| 题号                                                         | 题目             | 知识点   | 难度 |
| ------------------------------------------------------------ | ---------------- | -------- | ---- |
| [1](https://leetcode.cn/problems/two-sum)                    | 两数之和         | 哈希查表 | Easy |
| [242](https://leetcode.cn/problems/valid-anagram)            | 有效的字母异位词 | 哈希计数 | Easy |
| [349](https://leetcode.cn/problems/intersection-of-two-arrays) | 两数组交集       | set 运算 | Easy |

------

# 五、树（重点是二叉树、哈夫曼树思想）

| 题号                                                         | 题目              | 涉及结构    | 难度   |
| ------------------------------------------------------------ | ----------------- | ----------- | ------ |
| [144](https://leetcode.cn/problems/binary-tree-preorder-traversal) | 二叉树前序遍历    | 递归/栈模拟 | Easy   |
| [145](https://leetcode.cn/problems/binary-tree-postorder-traversal) | 后序遍历          | 树 + 递归   | Easy   |
| [226](https://leetcode.cn/problems/invert-binary-tree)       | 翻转二叉树        | 递归        | Easy   |
| [105](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal) | 根据前序+中序建树 | 构造树结构  | Medium |

📌 哈夫曼树相关：建议理解“最优合并”思想，可查 LeetCode 上合并石头的题（[1005](https://leetcode.cn/problems/stones-on-the-table) 类似但不完全对应）

------

# 六、Dijkstra 最短路径

| 题号                                                         | 题目         | 知识点        | 难度   |
| ------------------------------------------------------------ | ------------ | ------------- | ------ |
| [743](https://leetcode.cn/problems/network-delay-time)       | 网络延迟时间 | Dijkstra 算法 | Medium |
| [1631](https://leetcode.cn/problems/path-with-minimum-effort) | 最小体力路径 | Dijkstra 进阶 | Medium |

⚠️ 注意：图论题较难，先理解你课堂上实现的 Dijkstra，刷 [743] 就很足够！

------

# 七、贪心 & NP 完全问题近似解

| 题号                                                         | 题目       | 涉及策略      | 难度             |
| ------------------------------------------------------------ | ---------- | ------------- | ---------------- |
| [455](https://leetcode.cn/problems/assign-cookies)           | 分发饼干   | 贪心          | Easy             |
| [135](https://leetcode.cn/problems/candy)                    | 分发糖果   | 贪心+两遍扫描 | Hard（思路简单） |
| [435](https://leetcode.cn/problems/non-overlapping-intervals) | 无重叠区间 | 区间调度      | Medium           |

📌 这些题都可以用“局部最优”思想写出“近似最优解”，符合你课上 NP 完全问题部分的定位。

