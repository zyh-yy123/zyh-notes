# 数据库概论

## 一、发展历史

- 人工管理阶段

	>硬件：外部存储器只有磁带、卡片、纸带
	>软件：无操作系统，无数据管理软件
	>
	>特点：
	>
	>- 数据面向应用
	>- 数据不能保存
	>- 数据不能共享
	>- 不具有数据独立性

- 文件系统管理
	>硬件：直接存取设备
	>软件：文件系统
	>
	>特点：
	>
	>- 数据有一定的共享性
	>- 冗余
	>- 缺乏数据独立性

- 数据库系统管理
	>- 应用程序具有数据独立性
	>
	>	***


## 二、数据库概念

**数据库是长期存储在计算机内、有组织的、统一管理的、可共享的相关数据的集合**

### 1、数据管理的特点

- 采用数据模型组织数据
- 数据面向整个应用领域
- 数据由DBMS统一管理和控制
- 数据具有独立性

### 2、数据库管理系统DBMS

- 数据库的定义
- 数据操纵
- 数据的组织存储和管理
- 数据库的事务管理和运行管理（控制功能）
- 数据库的维护

### 3、数据库系统

>用户
>
>>应用程序
>>>应用开发工具
>>>>
>>>>DBMS
>>>>>操作系统OS
>>>>>>数据库

### 4、数据库管理员DBS

***

## 三、数据库系统结构

### 1、三级体系结构

| ANSI/SPARC体系结构的层次 | DBTG报告中的体系结构层次的层次 | 对应的抽象视图       | 用数据定义语言描述后的模式 |
| ------------------------ | ------------------------------ | -------------------- | -------------------------- |
| 外部级                   | 视图层                         | 用户视图             | 外模式（子模式）           |
| 概念级                   | 逻辑层                         | 全局视图（概念视图） | 概念模式（逻辑模式）       |
| 内部级                   | 物理层                         | 存储视图             | 内模式（存储模式）         |

### 2、实例和模式

实例：一个特定时刻数据库的即时数据

模式：

- 概念模式：**概念级**数据视图的描述，也称作逻辑模式，是数据库中全体数据的逻辑结构和特征的描述
- 外模式：数据库用户能看见和使用的局部数据的逻辑结构和特征的描述
- 内模式：数据库**物理存储结构和存储方式**的描述

概念模式与内模式可视为**设计与实现**的关系

注意：

- 概念模式独立于其他，设计数据库模式结构时应首先明确
- 内模式独立于外模式，独立于具体的存储设备但是依赖于概念模式
- 外模式定义在概念模式之上，独立于内模式和存储设备，面向具体的应用程序

***

## 四、数据的独立性

数据结构是数据对象在计算机中的组织方式，物理结构是数据在物理存储空间的存储方式

数据独立性是指用户的应用程序与其所处理的数据是相互独立的，当数据的逻辑结构或者物理结构变化时，应用程序保持不变
是在数据库系统中的某个层次修改模式而无需修改上一层模式的能力

- 物理独立性：修改内模式而无需修改概念模式
- 逻辑独立性：修改概念模式而无需修改外模式

***

## 五、数据模型

现实世界—>概念模型—>数据模型



### 1、概念模型

可用ER图（实体entity 联系）来描述，方框表示实体，菱形表示联系，无向边表明联系的类型（一对一、一对多、多对多）

**实体** 客观存在并且可以相互区别的实物
**实体型entity type** 用属性名来抽象和刻画同类实体 
**实体集entity set** 同型实体的集合
**属性attribute** 实体所具有的某一类特性 

>简单属性（原子属性）&复合属性
>存储属性（基本属性）&派生属性（导出属性）
>**域domain** ：属性的取值范围

**关键字key** 能**唯一**标识属性的**最小**属性集
每一个实体一定有关键字

**联系**

>实体集内、实体间的联系
>一元、多元联系
>
>两个实体集间的二元联系：
>
>- 1:1 对A中每一实体，B中至多有一个实体与之联系，反之亦然
>- 1:n 对A中每一实体，B中有n(n>=0)个实体与之联系,对B中实体则A中至多有1个实体与之联系
>- n:n
>
>**IS-A联系**对实体集A的一个子集，可以构造一个新的实体B，实体类型A成为超类，B成为子类
>B可以继承A的所有属性和与A相关的联系，同时有自己特有的属性（在ER图中用三角形）
>例如：type学生 type研究生
>
>**联系的属性** 联系本身也是一种实体型，也可以有属性

### 2、数据模型的组成要素

- 数据结构：

	> 描述数据库的组成对象以及对象之间的联系，反映的是数据静态特性

- 数据操作
	>对数据库中各种对象的实例允许执行的操作的集合，反映的是系统数据的动态变化
	>主要有**查询**和**更新**（插入删除修改）两大类

- 完整性约束
	>制约和依存限制，保证数据的正确，有效，相容

### 3、数据模型的演变

- 层次模型
	>基于树的结构
	>只能表示 1：n 的关系

- 网状模型
	>描述多对多
	>数据结构复杂，编程难度高

- **关系模型**
	**每个关系的数据结构都是一张规范的二维表**

- 半结构化模型
	>类似树，是节点的的集合，每个节点都从根节点可达

- 面向对象数据模型

### 4、关系模型概述

关系：满足一定语义的 D1 x D2 x … x D n的子集叫做在域D1、D2……上的关系

- 在关系模型中只有单一的数据结构——关系
- 关系既可以用来表示概念模型中的实体，也可以表示实体之间的各种联系

| 概念模型     | 关系模型     |
| ------------ | ------------ |
| 实体         | 关系         |
| 实体型       | 关系模式     |
| 实体集       | 关系实例     |
| 属性         | 属性         |
| 域           | 域           |
| 关键字（码） | 候选键（码） |

关系**R(U,D,Dom,F)**

R:关系名
U:组成该关系的属性集合 
D:属性组U中属性来自的域（**域都是原子数据的集合(表中不能再有表)——第一范式条件**）
Dom:属性向域的映像的集合（属性的类型和长度）
F:属性间数据的依赖关系（关系的属性之间的约束关系）



简化版**R(A1,A2,A3…An)**

关系R的实例 r(R) 动态

- 一个给定关系某一时刻的元组 的集合，即为当前关系的值

### 5、关系数据库

>应用领域中所有实体及实体之间联系所形成的关系的集合

| 集合的关系             | 关系模型中的关系                               |
| ---------------------- | ---------------------------------------------- |
| 关系可以是一个无限集合 | 关系必须是有限集合                             |
| 关系中每个元组是“序组” | 为关系的每个属性添加一个属性名取消分量的有序性 |

### 6、候选键和外键

#### 候选键

- 关系中能够**唯一**标识一个元组的**最小**属性集
- 若一个关系有多个候选键，选择其一位**主键**
- 包含候选键的属性集成为**超键**
- 若关系只有一个候选键，并且其包含了关系的所有属性，称之为**全键**
- 构成候选键的每个属性成为**主属性**

#### 外键

- 关系R的一个属性集F 与关系S的主键Ks对应
	即 关系R中的元组在F上的取值与关系S中元组的Ks上的值对应，则称该属性集F为关系R的外键
- R 参照关系（引用关系）
- S 被参照关系（目标关系）

>注意：
>外键与对应的主键必须定义在相同的值域上，即属性值的数据类型要完全一致



### 7、关系模型的完整性约束

#### 实体完整性规则

- 若属性A是关系R的主属性，则属性A的值不能为NULL



#### 参照完整性规则

- 若F是关系R的外键（对应S中的主键Ks）则其取值为：
	1.NULL
	2.S中某个元组的Ks值
- 实质是不允许引用不存在的实体



#### 用户定义完整性

- 针对某一具体关系数据库的约束条件，反映某一具体应用所涉及的数据必须满足的语义要求（如学生成绩数据库限制分数范围）





## 六、关系代数

**相容关系**：定义在一组相同域上的不同关系

>两个关系有相同的目，且相应的属性取值来自同一个域



#### 并

对于相容的关系R和S，并运算的结果是一个与之相容的关系，且其元组由属于R或S的元组组成

#### 差

相容关系R-S，R去掉R与S都有的的元组

#### 交

相容关系R和S都有的元组



#### 投影运算

>投影运算是一元的、对属性进行操作的与暖啊
>从关系中选择若干年属性列形成一个新的关系

π



#### 选择运算

>**一元的、对元组进行操作**的运算
>在关系中选择满足条件F的元组

δ



#### 乘积运算（广义笛卡尔积）

m目k1个元组的关系R与n目k2个元祖的关系S的笛卡尔积是一个m+n目，k1k2个元组的关系

若R、S有同名的属性A ，需要用R.A S.A区分

将两个关系进行笛卡尔积操作后有些元组是没有实际语义的，需要选择操作



#### 连接运算

Θ-连接运算从两个关系的笛卡尔积中选取属性之间满足一定条件的元组

- 当Θ为“=”时候，Θ-连接运算成为等值连接

- 自然连接是一种特殊的等值连接（去掉相同属性列）

- 外连接：在自然连接的结果上保留因在公共属性上没有相同属性值而被舍弃的元组(悬浮元组)，并且在这些元组新增加的属性赋空值
	>左外连接：只保留运算符左边关系中的悬浮元组
	>右外连接：只保留运算符右边关系中的悬浮元组

- 重命名 ρ s



#### 除法

注意，A / B 则B中属性类型为A中的真子集



#### 关系代数表达式





---

## 七、SQL语言

###  1、SQL概述

- structured query language

1. 综合统一
	>集成DDL DML DCL
	>
	>独立完成数据库生命周期的全部活动
	>
	>数据操作符统一

2. 高度非过程化
	>无需了解存取路径

3. 面向集合的操作方式

4. 同一种语法提供两种使用方法

5. 语言简单

	| 功能     | 动词                 |
	| -------- | -------------------- |
	| 数据查询 | SELECT               |
	| 数据定义 | CREATE,DROP,ALTER    |
	| 数据操纵 | INSERT,UPDATE,DELETE |
	| 数据控制 | GRANT,REVOKE         |



#### 基本表

1. 本身独立存在的表
2. SQL中一个关系对应一个基本表
3. 一个或多个基本表对应一个存储文件
4. 一个表可以带若干个index



#### 存储文件

1. 逻辑结构组成了关系数据库的内模式
2. 物理结构是任意的，对用户透明

#### 视图

1. 从一个或多个基本表==导出==的表
2. 是一个==虚表==（不独立存储在数据库中）
3. 数据库中**只存放视图的定义不存放视图对应的数据**
4. 可以在视图上再次定义视图

### 2、SQL数据定义

模式定义、表定义、视图和索引的定义

|      | 创建        | 删除       | 修改        |
| ---- | ----------- | ---------- | ----------- |
| 表   | CREAT TABLE | DROP TABLE | ALTER TABLE |
| 视图 | CREAT VIEW  | DROP VIEW  |             |
| 索引 | CREAT INDWX | DROP INDEX |             |

#### 定义模式

```sql
CREAT SCHEMA <模式名> AUTHORIZATION <用户名>
例如：
CREAT SCHEMA "S-T" AUTHORIZATION ZYH;
```



说明：

- 未指定模式名，schema默认为用户名
- 在CREAT SCHEMA中，可以接受CREAT TABLE\VIEW和CREAT字句
- 执行创建模式语句必须有DBA权限，或者DBA授予CREAT SCHEMA的权限



#### 删除模式

```sql
DROP SCHEMA <模式名> <CASCADE|RESTRICT>;
```

说明：

- CASCADE和RESTRICT二选一
- CASCADE（级联）：删除模式的同时把所有数据库对象删除
- RESTRICT（限制）：如果该模式中定义了下属的数据库对象（表、视图等），则拒绝执行删除语句

---

#### 表的定义

```sql
#尖括号<>表示根据实际情况写，方括号[]表示可有可无
CREATE TABLE <表名>
(<列名><数据类型>[<列级完整性约束条件>]
 [,<列名><数据类型>[<列级完整性约束条件>]]...
 [,<表级完整性约束条件>]
)；
```

说明：

- 如果完整性约束条件涉及到该表的多个属性列，则必须定义在表级，不然可以定义在列级或表级



例：

```sql
CREATE TABLE Student
(Sno CHAR(9) PRIMARY KEY,
 Sname CHAR(20) UNIQUE,
 Ssex CHAR(2),
 Sage SMALLINT,
 Sdept CHAR(20)
)
```

外键约束例：

```sql
CREATE TABLE Course
(Cno CHAR(4) PRIMARY KEY,
 Cname CHAR(40),
 Cpno CHAR(4),
 Ccredit SMALLINT,
 FOREIGN KEY (Cpno) REFERENCES (Course(Cno))
)
#Cpno是外码，被参照表是Course,被参照列是Cno
```

#### 数据类型

- CHAR(n) 定长字符串
- VARCHAR(n) 最大长度为n的字符串
- INT 整型
- SMALLINT 短整数
- NUMERIC(p,d) 定点数，p位数字（不包括符号小数点），小数点后d位数字
- REAL 取决于机器的浮点数
- Double Precision 取决于机器精度的双精度浮点数
- FLOAT(n) 浮点数
- DATE 日期 YYYY-MM-DD
- TIME 时间 HH:MM:SS



#### 模式和表

每一个基本表都属于某一个模式，一个模式包含多张基本表

创建基本表时，若没有指定模式，系统会搜索路径来确定：

1. 显示当前的搜索路径
	`SHOW search_path`
2. 搜索路径的当前默认值
	`$user,PUBLIC;`
3. DBA用户可以指定搜索路径
	`SET search_path TO "S-T",PUBLIC;`

找到后放到搜索路径的第一个，找不到就放到public，若都不存在报错

##### 创建基本表

1. 创建表的时候给出模式名

	```sql
	CREATE TABLE "S-T".Student(...)
	#属于模式"S-T"的表Student
	```

2. 同时创建

	```SQL
	CREATE SCHEMA ex AUTHORIZATION ZYH
	CREATE TABLE TAB1(...);
	```

3. 设置所属模式，创建表时不需给出模式名

---



#### 修改基本表

```sql
ALTER TABLE <表名>
[ADD[COLUMN]<列名><数据类型>[完整性约束]]
[ADD <表级完整性约束>]
[DROP [COLUMN] <列名> [RESTRICT|CASCADE]]
[ALTER COLUMN <列名> <数据类型>]；
```

说明：

1. ADD增加新列，新增加的列一律为NULL
2. DROP COLUMN 删除列，注意两种删除方法
3. DROP CONSTRAINT 删除指定的完整性约束
4. ALTER COLUMN修改原有的列定义

#### 删除基本表

```sql
DROP TABLE <表名> [CASCADE|RESTRICT]；
```

说明：

基本被删除，数据被删除，表上建立的索引、视图、触发器一般都被删除



#### 索引的建立与删除

建立的目的：加快查询速度

谁能建立索引：DMA或表的属主

DBMS一般会建立以下列的索引：

1. PRIMRAY KEY
2. UNIQUE

维护索引：DBMS自动完成

使用索引：DBMS自动选择



- 索引是数据库内部实现技术，属于内模式
- CREATE INDEX语句定义索引时，可以定义唯一索引、非唯一索引，或聚簇索引



语句格式：

```sql
CREATE [UNIQUE][CLUSTER]INDEX<索引名> ON <表名>(<列名>[<次序>][,<列名>[<次序>]]...)
```

例:

```sql
CREATE UNIQUE INDEX Stusno ON Student(Sno);
CREATE UNIQUE INDEX SCno ON SC(Sno ASC,Cno DESC)
#ASC升序，DESC降序
```

聚簇索引：

CLUSTER索引是指索引顺序与表中记录的物理顺序一致的索引组织（放在连续的存储空间）

- 在最经常查询的列建立聚簇索引能提高效率
- 一个基本表最多建立一个聚簇索引
- 经常更新的列不宜建立聚簇索引

删除索引：
`DROP INDEX <索引名>；`

删除索引时，系统会从数据字典删去有关该索引的描述

---

#### 数据字典

- DB内部的一组系统表
- 记录了数据库中的所有定义信息
- RDBMS执行SQL数据定义时，实际就是更新字典

---

### 3、数据查询

格式：

```sql
SELECT [ALL|DISTINCT]<目标表达式>[,<目标表达式>]...
FROM <表名或视图名>[,<表名或视图名>]..
[WHERE<条件表达式>]
[GROUP BY<列名>[HAVING<条件表达式>]]
[ORDER BY<列名>[ASC|DESC]]；
```

##### 单表查询

功能：对一个表的内容进行查询

1. 选择表中的若干列

	1. 查询指定列
		格式：

		```sql
		SELECT Sno,Sname FROM Student;
		```

	2. 查询全部列
		格式：

		```sql
		SELECT * FROM Student
		```

	3. 查询经过计算的值
		功能：选中指定列，计算后输出
		格式：

		```sql
		SELECT <> FROM 
		/*
		<>中可以是：
		算数表达式
		字符串常量
		函数
		列别名
		*/
		SELECT 2025-Sage FROM Student ;
		SELECT Sname,"year of birth:",2025-Sage,LOWER(Sdept) FROM Student;
		```

		使用列别名改变查询结果的列标题：

		```sql
		SELECT Sname NAME,"year of birth" BIRTH,2025-Sage BIRTHDAY,LOWDER(Sdept) DEPARTMENT FROM Student;
		```

2. 选择表中的若干元组

	1. 消除取值重复的行
		如果没有指定DISTINCT关键字，则缺省为ALL
		例：
		`SELECT Sno FROM SC;`
		等价于
		`SELECT ALL Sno FROM SC;`
		指定 DISTINCT关键字，去掉重复的行
		`SELECT DISTINCT Sno FROM SC;`

	2. 查询满足条件的元组

		| 查询条件             | 谓词                        |
		| -------------------- | --------------------------- |
		| 比较                 | =，<,>,!=                   |
		| 确定范围             | BETWEEN AND,NOT BETWEEN AND |
		| 确定集合             | IN,NOT IN                   |
		| 字符匹配             | LIKE,NOT LIKE               |
		| 空值                 | IS NULL,IS NOT NULL         |
		| 多重条件（逻辑运算） | AND,OR,NOT                  |

		例：
		集合：`SELECT Sname FROM Student WHERE Sdept IN("CS","IS")`

		字符匹配：`LIKE "<匹配串>" [ESCAPE "<换码字符>"]`

		>匹配串为含通配符字符串
		>
		>例：查询所有姓周的学生姓名
		>
		>`SELECT Sname FROM Student WHERE Sname LIKE "周%";`
		>
		>查询姓周且全名2个字
		>`SELECT Sname FROM Student WHERE Sname LIKE "周_";`
		>
		>查询第二个字为宇的
		>
		>`SELECT Sname FROM Student WHERE Sname LIKE "_宇%";`

		使用换码字符将通配符转义为普通字符（就是说我后面的字符就是单纯的字符，不表示特殊含义）：

		>`SELECT Cno FROM Course WHERE Cname LIKE "DB\_DESIGN ESCAPE '\'"`
		>
		>```SQL
		>#查询DB_开头且倒数第三个字符为i的课程的详细信息
		>SELECT * FROM Course 
		>WHERE Cname LIKE 'DB\_%i__' ESCAPE '\' 
		>```

		涉及空值的查询
		>`IS NULL` 或 `IS NOT NULL`
		>
		>例如：
		>
		>```SQL
		>#查询缺考的学生学号
		>SELECT Sno FROM SC
		>WHERE Grade IS NULL;
		>```

		多重条件查询

		>AND优先级高于OR

	3. ORDER BY 字句
		可以按照一个或多个属性列排序
		ASC DESC
		缺省值为升序
		当排序列含有空值：（空值默认最大）
		ASC/DESC排序列为空的元组最后/先显示

	4. 聚集函数

		```sql
		COUNT (DISTINCT|ALL *) 统计元组个数
		COUNT (DISTINCT|ALL <列名>) 统计一列中值的个数
		SUM (DISTINCT|ALL) <列名> 计算一列值的总和
		AVG (DISTINCT|ALL) <列名> 计算一列值的平均值
		MAX (DISTINCT|ALL) <列名> 最大值
		MIN (DISTINCT|ALL) <列名> 最小值
		```

		聚集函数不能写在 WHERE 之后

	5. GROUP BY字句
		作业：按照指定的一列或多列值分组，值相等的为一组，来细化聚集函数的作用对象
		**分组的好处在于能够使得聚集函数作用于需要的分组，否则作用于整个查询结果**
		**使用group by AAA 之后 SELECT后面只能跟AAA和作用于AAA的聚集函数**

	6. GROUP BY 分组之后，可以用HAVING单一指定筛选条件

		```sql
		#查询选了3门以上课程的学生
		SELECT Sno FROM SC GROUP BY Sno HAVING COUNT(*) > 3
		```

		区别WHERE和HAVING:

		- WHERE作用于基表或视图，选择满足条件的元组，HAVING短语作用于组，再次选择满足条件的组
		- WHERE中无法使用聚集函数（**WHERE之后只能有显然的观测，无法复杂运算**）



##### 连接查询

###### 等值与非等值查询

连接查询的WHERE子句中用来连接两个表的条件成为==连接条件或连接谓词==一般格式：

格式一：

`[<表名1>.]<列名1> <比较运算符> [<表名2>.]<列名2>；`

其中，比较运算符有：`=  >  <  >=  <=  !=`

格式二：

`[<表名1>.]<列名1> BETWEEN [<表名2>.]<列名2> AND [<表名3>.]<列名3>;`



- 当连接符号为 = ，称为==等值连接==，其他运算称为非等值连接
- 连接谓词中的列名称为连接字段，并且各连接字段必须是可比的，名字不必相同

自然连接:去掉重复列的等值连接

###### 自身连接

说明：

- 需要给表取别名来区分

例：求先修课的先修课

###### 外连接

左外连接：保留左边的悬浮元组

`LEFT OUT JOIN  ON`

右外连接：保留右边的悬浮元组

`RIGHT OUT JOIN ON`

```SQL
SELECT Student.Sno,Sname,Sage,Cno,Grade
FROM Student LEFT OUT JOIN SC ON (Student.Sno=SC.Sno)
```

###### 多表连接

连接2个以上的表





---

##### 嵌套查询

一个 `SELECT-FROM-WHERE`语句称为一个查询块

所谓嵌套查询，就是指将一个查询块嵌套在另一个查询块的WHERE子句或HAVING短语条件中的查询

说明：

1. 子查询中不能使用ORDER BY
2. 层层嵌套方式反映了SQL语言的结构化
3. 有些嵌套查询可以用链接运算符替代
4. 外层查询（父查询），内层查询（子查询）

嵌套查询中，子查询的结果往往是集合，用IN谓词表示父查询的条件在子查询的集合中

```sql
#查询和zyh在一个系的学生
SELECT Sno,Sname FROM Studen
WHERE Sdept IN
(SELECT Sdept FROM Student
WHERE Sname = 'zyh');

#法二
SELECT S1.Sno,S1.Sname,S1.Sdept
FROM Student S1,Student S2
WHERE S1.Sdept = S2.Sdept AND S2.Sname = 'zyh' ;
```



- 不相关子查询：子查询不依赖父查询
- 相关子查询：依赖

当确切知道内层查询返回单值时，可以用比较运算符

```sql
查询每个学生超过选修课程平均成绩的课程号
SELECT Sno,Cno
FROM SC x
WHERE Grade >=
(SELECT AVG(Grade)
 FROM SC y
 WHERE x.Sno=y.Sno
);
```



###### 带有ANY(SOME)或ALL谓词的子查询

ANY 任意一个值

ALL 所有值

例：

```sql
>ANY 大于某一个即可
>ALL 大于所有
!=ANY 不等于某一个即可
!=ALL 不等于所有
```

```SQL
SELECT Sname,Sage
FROM Student
WHERE  Sage < ANY (SELECT Sage FROM Student WHERE Sdept ='CS')
ADD Sdept != 'CS';
#使用聚集函数也可以完成
子查询改为：
SELECT MAX(Sage) FROM Student WHERE Sdept = 'CS'
```

###### 带有EXISTS谓词的子查询

EXISTS谓词代表存在量词 ，带有EXSITS谓词的子查询只返回逻辑值True 或 False

例子：

查询所有选修1号课程的学生姓名
>思路：
>
>1. 涉及Student和SC
>2. 在Student中一次取每一个 `Sno` 值，用这个值检查SC关系
>3. 若SC存在这样的元组，其 `Sno`值等于 `Student.Sno`且 `Cno='1'`，则选这个 `Student.Sname`进入结果关系

带有EXISTS的子查询都用 `SELECT *` 



NOT EXISTS谓词

取反即可



所有带有 IN,比较运算符，ANY,ALL的子查询都可以被EXISTS替换



可以用EXISISTS/NOT EXSISTS实现全程量词

$
\forall x\, p(x) \equiv \neg \exists x\, \neg p(x)
$

```sql
查询选修了全部课程的学生的姓名
等价于：没有一门课不选
SELECT Sname FROM Student
WHERE NOT EXISTS
(SELECT * FROM Course
 WHERE NOT EXISTS
 (SELECT * FROM SC
  WHERE Sno = Student.Sno AND Cno=Course.Cno
 )
);
```

